---
title: (작성중) SwiftUI를 위한 클린 아키텍처
date: 2020-12-20 09:00:00 +-0900
categories: [Architecture, SwiftUI]
tags: [translated, swiftui]     # TAG names should always be lowercase
---

## 원문

This is the translated article of "Clean Architecture for SwiftUI" in [https://nalexn.github.io/clean-architecture-swiftui/](https://nalexn.github.io/clean-architecture-swiftui/).  

Thank [Alexey Naumov](https://github.com/nalexn) for allowing me to post this article.  

이 글은 원문 "Clean Architecture for SwiftUI" 의 번역본입니다.  [https://nalexn.github.io/clean-architecture-swiftui/](https://nalexn.github.io/clean-architecture-swiftui/).  

이 글을 번역하도록 허락해 주신 [Alexey Naumov](https://github.com/nalexn)께 감사의 말씀 드립니다.  

## 서론

### 왜 이글을 번역하게 되었는가

이번에 학교 졸업 프로젝트에서 iOS개발을 할 일이 있었는데, 프로그램 설계를 많이 고민하면서 찾아보다가 해당 글을 발견하게 되었고, 이 글과 깃 허브를 참고하여 SwiftUI 프로젝트 설계를 깔끔하게 할 수 있었습니다.

다른 분들에게도 많은 도움이 될 것 같아서 저자에게 부탁하여 번역을 하게 되었습니다.

제가 했던 프로젝트 코드는 기업체와 함께 한 것이어서 공개할 수 없고, 차후에 제가 개인 프로젝트에 적용하게 된다면 링크를 다시 남겨드리겠습니다.

### 시작합니다

![하늘을 찌를 듯 높은 빌딩을 아래서 쳐다본 사진](https://nalexn.github.io/assets/img/clean_swiftui_01.jpg)

UIkit가 나온 지 벌써 11년이나 되었습니다. iOS SDK 가 2008년에 출시되었을 때부터 우리는 UIKit으로 앱 개발을 해왔습니다. 그 긴 시간 동안 개발자들은 각자의 앱에 적용할 최고의 아키텍처를 고민했습니다. MVC로 시작해서 MVP, MVVM, VIPER, RIBs, VIP에 이르기까지 다양합니다.

하지만 큰 변화가 찾아왔습니다. SwiftUI의 등장으로 지금까지 iOS를 위해 주로 쓰이던 아키텍처 패턴들은 역사 속으로 사라질 것입니다.

좋던 싫던 SwiftUI는 iOS 개발의 미래가 될 것입니다. 그리고 우리가 아키텍처를 설계할 때 직면하는 문제들을 해결할 때 새로운 방향을 제시할 것입니다.  

## SwiftUI의 개념적인 변화?

### 기존 UIKit

UIKit은 명령형(선언형 반대)이며 이벤트 중심의 프레임워크입니다. UIkit에서는 View hierarchy에서 각 뷰를 참조할 수 있고, 뷰의 로드 혹은 이벤트 발생(버튼 누르기 혹은 UITableView에 표시 가능해진 새 데이터 등장 등)에 대한 반응으로 뷰를 업데이트할 수 있습니다. 이러한 이벤트들을 핸들링하기 위해서 callbacks, delegates, target-action 등을 사용해왔습니다.  

### 현재의 SwiftUI

이제 그런 것들이 다 필요 없습니다. SwiftUI는 선언적, 상태(State) 중심의 프레임워크이기 때문입니다. SwiftUI에서는 View hierarchy를 통해 뷰를 참조할 수 없고, 이벤트에 대한 반응으로 직접적으로 뷰를 변경할 수도 없습니다. 대신 뷰에 바인딩 되어 있는 상태(State)를 변화시킵니다. Delegates, target-actions, responder chain, KVO 등의 모든 callback 기술들은 closure와 binding으로 대체되었습니다.

SwiftUI의 모든 뷰는 기본적으로 struct 타입입니다. 기존의 UIView class를 상속한 하위 class들에 비해서 생성 속도가 훨씬 빠릅니다. SwiftUI 컴포넌트, 즉, 각 struct들은 UI를 렌더링 하는데 사용되는 body 함수를 가지고 있고, body 함수에 영향을 미치는 state들에 대한 참조를 유지합니다.

따라서 SwiftUI의 View는 하나의 함수에 불과합니다. 입력으로 state를 주면 출력으로 화면을 그리는 것입니다. 출력을 바꾸는 유일한 방법은 입력을 바꾸는 것이 됩니다. View에 하위 View들을 추가하거나 제거하는 방식으로는 함수의 알고리즘(body 함수)을 변경할 수 없는 것입니다. 따라서 UI에 표현되는 모든 컴포넌트들은 body 함수 내부에 선언되어야 하고, runtime에 변경될 수 없습니다.  

다시 말해, SwiftUI에서는 하위 View들을 추가하고 제거하는 방식이 아니라 이미 만들어진 flowchart 알고리즘(body 함수)에서 UI 컴포넌트를 활성화하고 비활성화하는 방식으로 화면을 그리는 것입니다.  

## MVVM은 새로운 표준 아키텍처이다

SwiftUI는 MVVM 아키텍처가 내재되어 있습니다.

가장 간단한 예로 로컬 ```@State``` 변수를 생각할 수 있습니다. ```@State``` 변수는 ```ViewModel```의 역할을 하며 ```View```가 외부의 State에 의존적이지 않게 해줍니다. 또한 ```@State``` 변수는 State가 변할 때마다 UI가 리프레시 될 수 있도록 구독 메커니즘(```Binding```)을 제공합니다.

조금 더 복잡한 상황의 경우 ```View```는 별개의 ```ViewModel```인 외부의 ```ObservableObject```를 참조할 수 있습니다.

어찌 되었든, SwiftUI의 View가 State와 함께 작동하는 방식은 기존 MVVM과 정말 유사합니다. (더 복잡한 프로그래밍 엔티티 그래프에를 제시하지 않는 이상)

![UIKit에서 SwiftUI로의 변화를 설명하는 강연 사진](https://nalexn.github.io/assets/img/clean_swiftui_03.jpg)
> 이제 더 이상 ViewController는 필요하지 않습니다.

SwiftUI 앱에서 MVVM 모듈이 적용되는 간단한 예를 들어봅시다.

**Model**: 데이터 컨테이너

``` swift
struct Country {
    let name: String
}
```

**View**: SwiftUI 뷰

``` swift
struct CountriesList: View {
    
    @ObservedObject var viewModel: ViewModel
    
    var body: some View {
        List(viewModel.countries) { country in
            Text(country.name)
        }
        .onAppear {
            self.viewModel.loadCountires()
        }
    }
    
}
```

**ViewModel**: 비즈니스 로직(도메인)을 캡슐화한 ```ObservableObject```입니다. ```View```가 state에 대한 변화를 관찰할 수 있도록 허용합니다.

``` swift
extension CountriesList {
    class ViewModel: ObservableObject {
        @Published private(set) var countries: [Country] = []
        
        private let service: WebService
        
        func loadCountires() {
            service.getCountries { [weak self] result in
                self?.countries = result.value ?? []
            }
        }
    }
}
```

위의 예시에서 ```View```가 화면에 나타나게 되면 ```onAppear``` callback이 ```ViewModel```의 ```loadCountries()```를 호출하고, ```WebService```에 있는 데이터를 가져오게 됩니다. ```ViewModel```이 callback에 주어진 데이타를 받아 ```@Published```receives the data in the callback and pushes the updates through @Published variable countries, observed by the View.